import torch
from torch_geometric.data import Data
from torch_geometric.utils import (to_undirected, 
                                   structured_negative_sampling, 
                                   negative_sampling, 
                                   dropout_edge, dropout_node, subgraph)
import logging
from torch_geometric.data.separate import separate
import copy

def get_pos_neg_edges(
        g, sample_type='structured', 
        force_undirected=False, 
        neg_ratio=1.0,
    ):
    r""" we got 3 types target edges so far, cc_p2n, cc_p2p, cc_n2n.
    So we need to generate negative edges for each target edge type.
    This is a balanced data version.
    Args:
        g (pyg graph): the orignal homogenous graph.
        type (string): 'global' sampling or 'structured' sampling.
        force_undirected (bool): whether negative edges are undirected
        neg_ratio (float): average num of negative edges per positive edge
        sample_ratio (float): sample ratio for all edges
    Return:
        pos_edge_index (LongTensor 2xN), neg_edge_index (LongTensor 2xN),
        neg_edge_type (LongTensor N)
    """
    if neg_ratio > 1.0 or sample_type == 'global':
        neg_edge_index = negative_sampling(
            g.tar_edge_index, g.num_nodes,
            force_undirected=force_undirected,
            num_neg_samples=int(g.tar_edge_index.size(1)*neg_ratio),
        )
        
        neg_edge_type = torch.zeros(neg_edge_index.size(1), dtype=torch.long)
        for i in range(neg_edge_index.size(1)):
            node_pair = neg_edge_index[:, i]
            ntypes = set(g.node_type[node_pair].tolist())
            # for neg edge types are related to target edge types
            # weight for neg Cc_p2n
            if ntypes == {0, 2}: 
                neg_edge_type[i] = 2
            # weight for Cc_p2p
            elif ntypes == {2}:
                neg_edge_type[i] = 3
            # weight for Cc_n2n
            elif ntypes == {0}:
                neg_edge_type[i] = 4
        
        legal_mask = neg_edge_type > 0
        print(
            f"Using global negtive sampling, #pos={g.tar_edge_index.size(1)}, " + 
            f"#neg={neg_edge_index[:, legal_mask].size(1)}")
        return g.tar_edge_index, neg_edge_index[:,legal_mask], neg_edge_type[legal_mask]
    
    neg_edge_index = []
    neg_edge_type  = []
    tar_edge_offset = 0
    for i in range(g.tar_edge_dist.size(0)):
        pos_edges = g.tar_edge_index[:, tar_edge_offset:g.tar_edge_dist[i]+tar_edge_offset]
        pos_edge_src, pos_edge_dst, neg_edge_dst = structured_negative_sampling(
            pos_edges, g.num_nodes, contains_neg_self_loops=False,
        )
        tar_edge_offset += g.tar_edge_dist[i]
        # neg edge sampling
        indices = torch.randperm(neg_edge_dst.size(0))[
            :int(neg_edge_dst.size(0) * neg_ratio), 
        ]
        neg_edge_index.append(
            torch.stack((pos_edge_src[indices], neg_edge_dst[indices]), dim=0)
        )
        neg_edge_type += [i + g.tar_edge_type[0]] * indices.size(0)

        print(
            f"Using structured negtive sampling for target etype {i}, " + 
            f"pos={pos_edges.size(1)}, #neg={neg_edge_index[-1].size(1)}")
    
    return torch.cat(neg_edge_index, 1), torch.tensor(neg_edge_type)

def get_balanced_edges(
    g, neg_edge_index, neg_edge_type,
    neg_edge_ratio, sample_ratio = 1.0,
):
    r""" Get balanced edges according to their etypes, including both pos & neg edges.
    
    Args:
        g (Data): provides positive target edges and edge types.
        neg_edge_index (Tensor[2 x N]): neg edges generated by get_pos_neg_edges().
        neg_edge_type (Tensor[N]): neg edge types corresponding to pos edges.
        neg_edge_ratio (float): #neg edges per pos edge.
        sample_ratio (float): the proportion of samples to train.
    
    Return:
        pos_edge_index (Tensor [2, Npos]).
        pos_edge_type (Tensor [Npos]).
        pos_edge_y (Tensor [Npos]): target Cc values.
        neg_edge_index (Tensor [2, Nneg]).
        neg_edge_type (Tensor [Nneg]).
    """
    tar_edge_offset = 0
    min_edge_num = g.tar_edge_dist.min()
    neg_edge_index_list = []
    neg_edge_type_list  = []
    pos_edge_index_list = []
    pos_edge_type_list  = []
    pos_edge_y_list  = []
    for i in range(g.tar_edge_dist.size(0)):
        # for pos edges
        pos_edges = g.tar_edge_index[
            :, tar_edge_offset:g.tar_edge_dist[i]+tar_edge_offset
        ]
        pos_etypes = g.tar_edge_type[
            tar_edge_offset:g.tar_edge_dist[i]+tar_edge_offset
        ]
        pos_edge_y = g.tar_edge_y[
            tar_edge_offset:g.tar_edge_dist[i]+tar_edge_offset
        ]
        tar_edge_offset += g.tar_edge_dist[i]

        indices = torch.randperm(pos_edges.size(1))[
            :int(min_edge_num * sample_ratio), 
        ]
        pos_edge_index_list.append(pos_edges[:, indices])
        pos_edge_type_list.append(pos_etypes[indices])
        pos_edge_y_list.append(pos_edge_y[indices])
        
        logging.info(f"Edge type {i}, balanced pos edge num: {pos_edge_type_list[-1].size(0)}")

        # for neg edges
        neg_edge_mask = (neg_edge_type - neg_edge_type.min()) == i
        assert neg_edge_index.size(1) == neg_edge_type.size(0)
        neg_edges = neg_edge_index[:, neg_edge_mask]
        neg_etypes = neg_edge_type[neg_edge_mask]
        indices = torch.randperm(neg_edges.size(1))[
            :int(min_edge_num * neg_edge_ratio * sample_ratio), 
        ]
        neg_edge_index_list.append(neg_edges[:, indices])
        neg_edge_type_list.append(neg_etypes[indices])

        logging.info(f"Edge type {i}, balanced neg edge num: {neg_edge_type_list[-1].size(0)}")

    return (torch.cat(pos_edge_index_list, 1), torch.cat(pos_edge_type_list), 
            torch.cat(pos_edge_y_list),  # these are target Cc values
            torch.cat(neg_edge_index_list, 1), torch.cat(neg_edge_type_list),)



def collated_data_separate(data: Data, slices, idx: int=None):
    r""" 
    Reverse to InMemoryDataset.collate(),
    return the separated data_list from whole data chunk.
    """
    if idx is not None:
        separated_data = separate(
            cls=data.__class__,
            batch=data,
            idx=idx,
            slice_dict=slices,
            decrement=False,
        )
        return copy.copy(separated_data)
    
    data_list = []
    for i in range(data.y.size(0)):
        separated_data = separate(
            cls=data.__class__,
            batch=data,
            idx=i,
            slice_dict=slices,
            decrement=False,
        )
        data_list.append(copy.copy(separated_data))
    return data_list